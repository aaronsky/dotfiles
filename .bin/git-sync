#!/bin/sh

rootpath=$(git rev-parse --show-toplevel)
cd $rootpath

[[ $# -eq 0 ]] && echo "Insufficient arguments.\n\nUsage: git-sync <remote> [<branch-name>]" && exit 1

OTHER_REMOTE=$1

if [[ -z "$2" ]] ; then
    OTHER_BRANCH=$(git rev-parse --abbrev-ref HEAD)
else
    OTHER_BRANCH=$2
fi

# Stores CURRENT_REMOTE and CURRENT_BRANCH
CURRENT_REMOTE_REF=$(git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD))
IFS='/' read -r CURRENT_REMOTE CURRENT_BRANCH <<< "$CURRENT_REMOTE_REF"

[[ "$CURRENT_REMOTE" == "$OTHER_REMOTE" ]] && echo "Current remote and sync remote are the same" && exit 1
[[ "$CURRENT_BRANCH" != "$OTHER_BRANCH" ]] && echo "Current branch and sync branch do not match ($CURRENT_BRANCH, $OTHER_BRANCH)" && exit 1
[ -z $(git rev-parse --verify --quiet "$OTHER_REMOTE/$OTHER_BRANCH") ] && echo "$OTHER_REMOTE/$OTHER_BRANCH does not exist" && exit 1

git fetch $OTHER_REMOTE $OTHER_BRANCH

COMMIT_MSG_QUERY=$(git log -1 --pretty=%B)
COMMIT_MATCHING_HEAD=$(git log --pretty=format:"%H" --first-parent --grep="$COMMIT_MSG_QUERY" $OTHER_REMOTE/$OTHER_BRANCH)
echo "Rebasing commits onto $CURRENT_BRANCH from $COMMIT_MATCHING_HEAD to $OTHER_REMOTE/$OTHER_BRANCH"

git rebase --onto $CURRENT_BRANCH $COMMIT_MATCHING_HEAD $OTHER_REMOTE/$OTHER_BRANCH
git branch -f $OTHER_BRANCH
git checkout $OTHER_BRANCH

echo "All done! Run \`git push $CURRENT_REMOTE $CURRENT_BRANCH\` when you're ready to push."
